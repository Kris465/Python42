# Парадигмы программирования

    Парадигмы программирования представляют собой различные подходы к организации и структуре программного кода. Вот основные парадигмы, которые широко используются в программировании:

1. Императивное программирование

• Описание: В этой парадигме программы описываются как последовательность инструкций, которые изменяют состояние программы.

• Примеры языков: C, Java, Python.

• Особенности: Использует конструкции управления потоком, такие как циклы и условные операторы.

2. Декларативное программирование

• Описание: В декларативном программировании акцент делается на том, что должно быть сделано, а не на том, как это сделать. Программист описывает желаемый результат.

• Примеры языков: SQL, HTML, Prolog.

• Особенности: Часто используется в контексте баз данных и веб-разработки.

3. Объектно-ориентированное программирование (ООП)

• Описание: Эта парадигма основывается на концепции "объектов", которые содержат данные и методы для работы с этими данными.

• Примеры языков: Java, C++, Python, Ruby.

• Особенности: Ключевые концепции включают инкапсуляцию, наследование и полиморфизм.

4. Функциональное программирование

• Описание: В функциональном программировании акцент ставится на использование функций как основных строительных блоков. Функции являются первоклассными объектами.

• Примеры языков: Haskell, Lisp, Scala, JavaScript (в некоторых аспектах).

• Особенности: Использует концепции чистых функций, неизменяемости и высших функций.

5. Логическое программирование

• Описание: Программы описываются в виде логических выражений, и выполнение программы сводится к выводу из этих выражений.

• Примеры языков: Prolog.

• Особенности: Применяется в задачах, связанных с искусственным интеллектом и решением логических задач.

6. Параллельное и конкурентное программирование

• Описание: Эти парадигмы ориентированы на выполнение нескольких вычислений одновременно, чтобы повысить производительность.

• Примеры языков: Go, Erlang, Java (с использованием потоков).

• Особенности: Включает управление потоками и синхронизацию.

7. Реактивное программирование

• Описание: Эта парадигма фокусируется на асинхронных потоках данных и распространении изменений. Она позволяет реагировать на события в реальном времени.

• Примеры языков/библиотек: RxJava, RxJS.

• Особенности: Использует концепции наблюдателей и потока данных.

8. Событийно-ориентированное программирование

• Описание: Программы организованы вокруг событий и обработчиков событий. Это часто используется в разработке пользовательских интерфейсов.

• Примеры языков: JavaScript (в браузерах), C# (в .NET).

• Особенности: Реакция на пользовательские действия или события системы.

## ООП (Объектно-ориентированное программирование)

Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на концепции "объектов", которые объединяют данные и методы для работы с этими данными. ООП позволяет создавать более структурированные, гибкие и масштабируемые программы. Давайте подробнее рассмотрим основные принципы и концепции ООП.

### Основные концепции ООП

1. Объекты:

   • Объект — это экземпляр класса, который содержит данные (атрибуты) и функции (методы), которые могут работать с этими данными.

   • Пример: В классе Автомобиль объектом может быть конкретный автомобиль, например, Toyota Camry.

2. Классы:

   • Класс — это шаблон для создания объектов. Он определяет структуру данных (атрибуты) и поведение (методы) объектов.

   • Пример: Класс Автомобиль может иметь атрибуты, такие как цвет, модель, год выпуска, и методы, такие как ехать(), тормозить().

3. Инкапсуляция:

   • Инкапсуляция — это механизм скрытия внутреннего состояния объекта и предоставления доступа к нему только через публичные методы. Это помогает защитить данные от некорректного использования.

   • Пример: В классе Автомобиль можно сделать атрибуты скорость и топливо приватными, а доступ к ним предоставлять через методы изменитьСкорость() и проверитьТопливо().

4. Наследование:

   • Наследование позволяет создавать новый класс на основе существующего, наследуя его свойства и методы. Это способствует повторному использованию кода.

   • Пример: Класс Электромобиль может наследовать класс Автомобиль и добавлять свои специфические атрибуты, такие как емкость батареи.

5. Полиморфизм:

   • Полиморфизм позволяет использовать один интерфейс для работы с разными типами объектов. Это может быть достигнуто через переопределение методов в подклассах.

   • Пример: Метод ехать() может быть реализован по-разному в классах Автомобиль и Велосипед, но оба класса могут использоваться в одном контексте.

### Преимущества ООП

• Упрощение разработки: ООП способствует более четкой организации кода и облегчает его понимание и поддержку.

• Повторное использование кода: Благодаря наследованию и полиморфизму можно повторно использовать уже написанный код.

• Модульность: Объекты могут быть разработаны и протестированы отдельно, что упрощает процесс разработки.

• Гибкость и расширяемость: Легко добавлять новые функции или изменять существующие без необходимости переписывать весь код.

### Недостатки ООП

• Сложность: Для небольших проектов использование ООП может привести к излишней сложности.

• Производительность: В некоторых случаях из-за уровня абстракции производительность может быть ниже по сравнению с процедурным программированием.

• Переусложнение: Иногда разработчики могут переусложнять архитектуру, создавая слишком много классов и объектов.

## Python

Объектно-ориентированное программирование (ООП) в Python — это мощный подход к разработке программного обеспечения, который позволяет создавать более структурированные и управляемые приложения. Вот ключевые концепции и аспекты, которые важно знать о ООП в Python:

1. Основные принципы ООП

• Инкапсуляция: Это принцип сокрытия данных. В Python инкапсуляция достигается с помощью модификаторов доступа (например, использование одного или двух подчеркиваний перед именем атрибута). Это позволяет скрыть внутренние детали реализации и защищает данные от некорректного использования.

```Python
    class BankAccount:
        def __init__(self, balance):
            self.__balance = balance  # Приватный атрибут

        def deposit(self, amount):
            self.__balance += amount

        def get_balance(self):
            return self.__balance

    account = BankAccount(100)
    account.deposit(50)
    print(account.get_balance())  # Вывод: 150
    
```

• Наследование: Позволяет создавать новый класс на основе существующего, что способствует повторному использованию кода. Подкласс наследует атрибуты и методы родительского класса.

```Python
    class Animal:
        def speak(self):
            return "Animal speaks"

    class Dog(Animal):
        def speak(self):
            return "Woof!"

    dog = Dog()
    print(dog.speak())  # Вывод: Woof!
    
```

• Полиморфизм: Позволяет использовать один интерфейс для работы с разными типами объектов, как уже обсуждалось ранее.

2. Абстрактные классы и интерфейсы

Python поддерживает абстрактные классы через модуль abc. Абстрактные классы могут содержать абстрактные методы, которые должны быть реализованы в подклассах.

```Python
from abc import ABC, abstractmethod

class Vehicle(ABC):
    @abstractmethod
    def start(self):
        pass

class Car(Vehicle):
    def start(self):
        return "Car started"

class Bike(Vehicle):
    def start(self):
        return "Bike started"
```

3. Композиция против наследования

• Наследование: Используется, когда один класс является специализированной версией другого.

• Композиция: Используется, когда один класс содержит экземпляр другого класса и делегирует ему определенные задачи. Это часто более гибкий подход.

```Python
class Engine:
    def start(self):
        return "Engine started"

class Car:
    def __init__(self):
        self.engine = Engine()  # Композиция

    def start(self):
        return self.engine.start() + " and Car is ready"

car = Car()
print(car.start())  # Вывод: Engine started and Car is ready
```

4. Специальные методы (магические методы)

Python поддерживает множество специальных методов (или магических методов), которые позволяют изменять поведение встроенных операций для ваших классов. Например:

• __init__: Конструктор класса.

• __str__: Определяет строковое представление объекта.

• __repr__: Определяет официальное строковое представление объекта.

• __add__, __sub__ и другие: Определяют поведение операторов.

```Python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)

    def __str__(self):
        return f"Point({self.x}, {self.y})"

p1 = Point(1, 2)
p2 = Point(3, 4)
print(p1 + p2)  # Вывод: Point(4, 6)
```

5. Множественное наследование

Python поддерживает множественное наследование, что означает, что класс может наследовать от нескольких родительских классов. Однако это может привести к сложности и проблемам с разрешением имен (например, "алмазная проблема").

```Python
class A:
    pass

class B(A):
    pass

class C(A):
    pass

class D(B, C):
    pass
```

6. Декораторы и свойства

Декораторы позволяют изменять или расширять функциональность методов и свойств классов. Свойства (@property) позволяют использовать методы как атрибуты.

```Python
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        return self._radius
        @radius.setter
    def radius(self, value):
        if value < 0:
            raise ValueError("Radius cannot be negative")
        self._radius = value

circle = Circle(5)
print(circle.radius)  # Вывод: 5
circle.radius = 10
print(circle.radius)  # Вывод: 10

```

### Классы и объекты

Начнем с создания класса и создания объекта этого класса.

```Python
class Car:
    def __init__(self, make, model, year):
        self.make = make      # марка автомобиля
        self.model = model    # модель автомобиля
        self.year = year      # год выпуска

    def display_info(self):
        print(f"{self.year} {self.make} {self.model}")

# Создание объекта класса Car
my_car = Car("Toyota", "Camry", 2020)
my_car.display_info()  # Вывод: 2020 Toyota Camry
```

### self

В Python self — это ссылка на текущий экземпляр класса. Она используется в методах класса для доступа к атрибутам и другим методам этого экземпляра. self позволяет объекту ссылаться на свои собственные данные и функциональность, что является важной частью объектно-ориентированного программирования.

    1. Необязательное имя: Хотя принято использовать self, это не зарезервированное слово в Python. Вы можете использовать любое другое имя, но использование self является общепринятой практикой и делает код более понятным для других разработчиков.

    2. Обязательный первый параметр: В методах класса self всегда должен быть первым параметром. Это позволяет методу знать, к какому экземпляру класса он относится.

    3. Доступ к атрибутам и методам: Используя self, вы можете получать доступ к атрибутам и методам экземпляра класса. Это позволяет вам изменять состояние объекта и вызывать другие методы в рамках того же объекта.

Пример использования self

Вот простой пример, который демонстрирует использование self в классе:

```Python
class Dog:
    def __init__(self, name, age):
        self.name = name  # Присваиваем атрибуту name значение
        self.age = age    # Присваиваем атрибуту age значение

    def bark(self):
        print(f"{self.name} says Woof!")

    def get_age(self):
        return self.age

# Создание экземпляра класса Dog
my_dog = Dog("Buddy", 3)

# Вызов методов
my_dog.bark()  # Вывод: Buddy says Woof!
print(my_dog.get_age())  # Вывод: 3
```

Объяснение примера

1. Конструктор (__init__): В этом методе мы используем self для присвоения значений атрибутам name и age. Эти атрибуты будут уникальны для каждого экземпляра класса.

2. Методы: Методы bark и get_age используют self для доступа к атрибутам name и age. Это позволяет каждому объекту класса Dog иметь свои собственные значения этих атрибутов.

### Пространство имен

Пространство имен (или namespace) в Python — это концепция, которая помогает организовать и управлять именами идентификаторов (переменных, функций, классов и т. д.) в программе. Пространства имен позволяют избежать конфликтов имен и обеспечивают изоляцию между различными частями кода.

1. Что такое пространство имен?
   Пространство имен — это контейнер для имен, который обеспечивает уникальность идентификаторов в определенном контексте. Каждый идентификатор в Python имеет свое пространство имен, что позволяет использовать одно и то же имя в разных контекстах без конфликтов.

2. Типы пространств имен:

   • Локальное пространство имен: Создается при вызове функции и содержит имена переменных, определенных внутри этой функции.

   • Глобальное пространство имен: Содержит имена, определенные на уровне модуля. Эти имена доступны во всей области видимости модуля.

   • Встроенное пространство имен: Содержит предопределенные имена, доступные во всех модулях Python (например, len, print и т. д.).

3. Области видимости:

   • Локальная область видимости: Имена, определенные внутри функции, доступны только в этой функции.

   • Глобальная область видимости: Имена, определенные на уровне модуля, доступны во всем модуле.

   • Встроенная область видимости: Имена, доступные во всех модулях.

Пример использования пространств имен

Вот пример, который иллюстрирует использование локальных и глобальных пространств имен:

```Python
x = 10  # Глобальная переменная

def my_function():
    x = 5  # Локальная переменная
    print("Локальное значение x:", x)

my_function()  # Вывод: Локальное значение x: 5
print("Глобальное значение x:", x)  # Вывод: Глобальное значение x: 10
```

Объяснение примера

1. Мы создаем глобальную переменную x с значением 10.

2. Внутри функции my_function мы создаем локальную переменную x с значением 5. Эта локальная переменная скрывает (или "затеняет") глобальную переменную x в контексте этой функции.

3. Когда мы вызываем my_function, она выводит локальное значение x, равное 5.

4. После выхода из функции мы можем получить доступ к глобальной переменной x, которая по-прежнему равна 10.

### Инкапсуляция

В Python, как и в других языках программирования, атрибуты классов могут иметь различные уровни доступа, которые помогают контролировать, как и где они могут быть использованы. В Python принято использовать три уровня доступа: public, protected и private.

1. Public (публичные) атрибуты

Public атрибуты — это атрибуты, которые доступны из любого места в коде. Они создаются без какого-либо специального префикса.

```Python
class Example:
    def __init__(self):
        self.public_attr = "I am public"

example = Example()
print(example.public_attr)  # Доступно из вне класса
```

2. Protected (защищенные) атрибуты

Protected атрибуты обозначаются одним подчеркиванием (_) перед именем атрибута. Это является соглашением о том, что данный атрибут предназначен для использования только внутри класса и его подклассов. Однако это всего лишь соглашение — на практике доступ к таким атрибутам возможен из вне, но это не рекомендуется.

```Python
class Base:
    def __init__(self):
        self._protected_attr = "I am protected"

class Derived(Base):
    def show(self):
        print(self._protected_attr)  # Доступно в подклассе

base = Base()
print(base._protected_attr)  # Доступно, но не рекомендуется
```

3. Private (приватные) атрибуты

Private атрибуты обозначаются двумя подчеркиваниями (__) перед именем атрибута. Это создает "имя mangling" (изменение имени), что затрудняет доступ к этому атрибуту из вне класса. Приватные атрибуты предназначены для использования только внутри класса, и доступ к ним из подклассов или внешнего кода затруднен.

```Python
class Example:
    def __init__(self):
        self.__private_attr = "I am private"

    def get_private_attr(self):
        return self.__private_attr  # Метод для доступа к приватному атрибуту

example = Example()
# print(example.__private_attr)  # Это вызовет ошибку AttributeError
print(example.get_private_attr())  # Правильный способ доступа
```

Сравнение уровней доступа

| Уровень доступа | Обозначение      | Доступность                                                                 |
|-----------------|------------------|-----------------------------------------------------------------------------|
| Public          | attr           | Доступен из любого места, включая внешние модули и классы.               |
| Protected       | _attr          | Рекомендуется использовать только внутри класса и его подклассов. Доступен, но нежелателен извне. |
| Private         | __attr         | Доступен только внутри класса. Доступ извне затруднен (но не невозможен). |

Примечание о "имя mangling"

Для приватных атрибутов Python использует механизм "имя mangling", чтобы избежать конфликтов имен в подклассах. Например, если вы создаете класс с приватным атрибутом __attr, он будет доступен как _ClassName__attr извне:

```Python
class Example:
    def __init__(self):
        self.__private_attr = "I am private"

example = Example()
print(example._Example__private_attr)  # Доступ к приватному атрибуту через имя mangling
```

### Наследование
Наследование в Python — это механизм, который позволяет создавать новые классы на основе существующих. Новый класс (называемый производным или подклассом) наследует атрибуты и методы родительского класса (или базового класса). Это позволяет повторно использовать код и создавать более сложные структуры данных.

1. Родительский и дочерний классы: Родительский класс — это класс, от которого наследуется, а дочерний класс — это класс, который наследует.

2. Переопределение методов: Дочерний класс может переопределить методы родительского класса, чтобы изменить или расширить их поведение.

3. Множественное наследование: Python поддерживает множественное наследование, что означает, что класс может наследовать от нескольких классов.

Вот простой пример, который демонстрирует наследование в Python:

```Python
# Родительский класс
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        return "Some sound"

# Дочерний класс
class Dog(Animal):
    def speak(self):
        return "Woof!"

# Другой дочерний класс
class Cat(Animal):
    def speak(self):
        return "Meow!"

# Создаем объекты
dog = Dog("Buddy")
cat = Cat("Whiskers")

# Выводим результаты
print(f"{dog.name} says: {dog.speak()}")  # Вывод: Buddy says: Woof!
print(f"{cat.name} says: {cat.speak()}")  # Вывод: Whiskers says: Meow!
```

Объяснение примера

1. Родительский класс Animal:

   • Имеет метод __init__, который инициализирует имя животного.

   • Имеет метод speak, который возвращает строку "Some sound".

2. Дочерний класс Dog:

   • Наследует от класса Animal.

   • Переопределяет метод speak, чтобы возвращать строку "Woof!".

3. Дочерний класс Cat:

   • Также наследует от класса Animal.

   • Переопределяет метод speak, чтобы возвращать строку "Meow!".

4. Создание объектов:

   • Создаем объект dog класса Dog и объект cat класса Cat.

   • Вызываем метод speak для каждого объекта, чтобы получить соответствующие звуки.

### Полиморфизм

Полиморфизм — это один из ключевых принципов объектно-ориентированного программирования (ООП), который позволяет объектам разных классов обрабатывать данные по одному и тому же интерфейсу. Это означает, что разные объекты могут быть обработаны одним и тем же способом, даже если они принадлежат к различным классам.

1. Полиморфизм по подтипам (или "параметрический полиморфизм"): это когда методы в разных классах имеют одинаковые имена, но могут выполнять разные действия в зависимости от класса объекта.

2. Полиморфизм через интерфейсы: когда разные классы реализуют один и тот же интерфейс.

Пример 1: Полиморфизм через наследование

В этом примере мы создадим базовый класс Animal и два подкласса Dog и Cat, которые реализуют метод speak() по-разному.

```Python
class Animal:
    def speak(self):
        raise NotImplementedError("Subclass must implement abstract method")

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

def animal_sound(animal):
    print(animal.speak())

# Создаем объекты
dog = Dog()
cat = Cat()

# Используем полиморфизм
animal_sound(dog)  # Вывод: Woof!
animal_sound(cat)  # Вывод: Meow!
```

В этом примере функция animal_sound() принимает объект типа Animal и вызывает метод speak(). Благодаря полиморфизму, она может работать как с объектами класса Dog, так и с объектами класса Cat.

▎Пример 2: Полиморфизм через интерфейсы

Интерфейсы в Python не определяются явно, как в некоторых других языках (например, Java), но мы можем использовать абстрактные базовые классы (ABC) для достижения аналогичного результата.

```Python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2

def print_area(shape):
    print(f"Area: {shape.area()}")

# Создаем объекты
rectangle = Rectangle(10, 5)
circle = Circle(7)

# Используем полиморфизм
print_area(rectangle)  # Вывод: Area: 50
print_area(circle)     # Вывод: Area: 153.86
```

В этом примере у нас есть абстрактный класс Shape, который определяет метод area(). Классы Rectangle и Circle реализуют этот метод по-разному. Функция print_area() может принимать любой объект типа Shape и корректно вызывать метод area().

